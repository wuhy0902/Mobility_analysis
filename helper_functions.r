plot_map_help <- function() {
  cat("Generate a Map with Anchor Points and Line Segments\n\n",
      "This function creates a map with anchor points and line segments.\n",
      "It provides an option to save the plot as a PDF.\n\n",
      "Usage:\n",
      "  plot_map(save_path_name = 'No')\n\n",
      "Arguments:\n",
      "  save_path_name (string) - The file path to save the plot.\n",
      "                             If not provided or set to 'No', \n",
      "                             the plot is displayed but not saved.\n\n",
      "Examples:\n",
      "  plot_map()  # Display the plot without saving\n",
      "  plot_map(save_path_name = 'pic/basic/map/map.pdf')  # Save the plot to a file\n",
      sep = "")
}

ref_distri_help <- function() {
  cat("Generate Reference Distribution for Observations\n\n",
      "This function simulates observations over multiple days, computes density estimates, \n",
      "and returns grid-based distribution data for both true and observed locations.\n\n",
      "Usage:\n",
      "  ref_distri(days = 100, freq_parameter = 1439, measurement_error = 0.1, \n",
      "             running_amount = 100, distri_true_need = 'yes', \n",
      "             time_interval = c(0, 1), grid_cell_size = 0.2, way_of_ref = 'cell_obs_count')\n\n",
      "Arguments:\n",
      "  days (integer) - Number of days to simulate in each running.\n",
      "  freq_parameter (integer) - Number of observations per day.\n",
      "  measurement_error (numeric) - Error in measurement.\n",
      "  running_amount (integer) - Number of simulation runs.\n",
      "  distri_true_need (string) - Whether to compute true density reference ('yes' or 'no').\n",
      "  time_interval (vector) - Time range for observations.\n",
      "  grid_cell_size (numeric) - Size of each grid cell.\n",
      "  way_of_ref (string) - Method of computing the reference distribution ('cell_obs_count' (Monte-Carlo) or 'kde (KDE)').\n\n",
      "Returns:\n",
      "  A list containing:\n",
      "  - distri_ref: Estimated observed density distribution.\n",
      "  - distri_ref_true: True density distribution (if requested).\n",
      "  - grid_centers: Coordinates of grid centers.\n",
      "  - grid_need: Grid information.\n\n",
      "Examples:\n",
      "  ref_distri_info = ref_distri(100, 1439, 0.1, 100, 'yes', c(0, 1), 0.2, 'cell_obs_count')\n",
      "  grid_centers = ref_distri_info$grid_centers\n",
      "  observed_density = ref_distri_info$distri_ref\n",
      "  true_density = ref_distri_info$distri_ref_true\n",
      sep = "")
}

# Helper function to display function documentation manually
kde_estimation_help <- function() {
  cat("Kernel Density Estimation for Observations\n\n",
      "This script estimates densities using different kernel density estimation (KDE) methods \n",
      "and computes estimation errors by comparing with the true density.\n\n",
      "Usage:\n",
      "  kde_gps(obs_input, grid_center_need, method, t_range_need=NULL, \n",
      "          time_interval=c(0, 0.99999), hs_const=0.8, ht_const=0.3)\n\n",
      "Arguments:\n",
      "  obs_input (data.frame) - The observed data containing timestamps and coordinates.\n",
      "  grid_center_need (matrix) - The grid centers where KDE is estimated.\n",
      "  method (string) - The KDE method to use ('naive', 'marginal', 'integral_conditional', 'naive_naive_bandwidth').\n",
      "  t_range_need (vector, optional) - Time range for integral conditional KDE.\n",
      "  time_interval (vector) - Time range for KDE estimation.\n",
      "  hs_const (numeric) - Smoothing parameter for spatial bandwidth.\n",
      "  ht_const (numeric) - Smoothing parameter for temporal bandwidth.\n\n",
      "Returns:\n",
      "  Estimated density values for the specified method and grid centers.\n\n",
      "Examples:\n",
      "  naive_density = kde_gps(observations_multiple_days, grid_center_need, 'naive')\n",
      "  marginal_density = kde_gps(observations_multiple_days, grid_center_need, 'marginal')\n",
      "  integral_density = kde_gps(observations_multiple_days, grid_center_need, 'integral_conditional', t_range_need=t_range_need)\n\n",
      "To evaluate accuracy:\n",
      "  error_naive = esti_error(true_density_for_obs, naive_density, grid_center_need)\n",
      "  error_marginal = esti_error(true_density_for_obs, marginal_density, grid_center_need)\n",
      sep = "")
}


# Helper function to display function documentation manually
video_generate_help <- function() {
  cat("Generate an Animation of Observed Data\n\n",
      "This function creates an animation from observed data over multiple days\n",
      "and encodes it into a video file.\n\n",
      "Usage:\n",
      "  video_generate(observations_multiple_days_video, video_name = 'obs_animation.mp4')\n\n",
      "Arguments:\n",
      "  observations_multiple_days_video (data.frame) - The observed data containing timestamps and coordinates.\n",
      "  video_name (string, optional) - The filename for the output video (default: 'obs_animation.mp4').\n\n",
      "Returns:\n",
      "  A video file displaying the animation of the observed data.\n\n",
      "Examples:\n",
      "  observations_multiple_days_video = data_generation(7, freq_pattern, 479, measurement_error, goal_interval, running_time)[[2]]\n",
      "  video_generate(observations_multiple_days_video, 'obs_animation.mp4')\n\n",
      "To view function details, run:\n",
      "  video_generate_help()\n",
      sep = "")
}

# Helper function to display function documentation manually
density_plot_help <- function() {
  cat("Density Plot Visualization\n\n",
      "This function visualizes density estimates using log-transformed contour plots.\n",
      "It supports LaTeX expressions for titles and can save plots to a PDF file.\n\n",
      "Usage:\n",
      "  density_plot(density_to_plot, eps, grid_center_need, title, \n",
      "              mtext_in_plot, min_max_range, save_path_name='No')\n\n",
      "Arguments:\n",
      "  density_to_plot (matrix) - The density values to be plotted.\n",
      "  eps (numeric) - A small constant added to avoid log(0).\n",
      "  grid_center_need (matrix) - Coordinates of grid centers for contour plotting.\n",
      "  title (string) - Plot title, supports LaTeX expressions.\n",
      "  mtext_in_plot (string) - Additional text for the plot.\n",
      "  min_max_range (numeric vector) - Range for color scaling.\n",
      "  save_path_name (string) - File path to save the plot (default: 'No' to disable saving).\n\n",
      "Returns:\n",
      "  A contour plot of the density values with a color scale.\n\n",
      "Examples:\n",
      "  density_plot(true_density_for_obs, 0.0001, grid_center_need, \n",
      "               TeX('$\\log(f_{GPS}+\\xi),$ (overall)'), '', \n",
      "               max_min_range, save_path_name='pic/basic/density_plot/true_density_overall.pdf')\n\n",
      "To view function details, run:\n",
      "  density_plot_help()\n",
      sep = "")
}

# Helper function to display function documentation manually
data_generation_help <- function() {
  cat("Generate Observational Data\n\n",
      "This function generates movement patterns and observational data \n",
      "over multiple days based on user-specified parameters.\n\n",
      "Usage:\n",
      "  data_generation(days, frequency_pattern, freq_parameter, \n",
      "                 measurement_error, goal_interval, running_time)\n\n",
      "Arguments:\n",
      "  days (integer) - The number of days to simulate.\n",
      "  frequency_pattern (string) - The pattern of observations ('even_space', 'irregular', etc.).\n",
      "  freq_parameter (integer) - The number of observations per day.\n",
      "  measurement_error (numeric) - The error in measurement applied to observations.\n",
      "  goal_interval (vector) - The time range for the observations.\n",
      "  running_time (integer) - A unique identifier for reproducibility.\n\n",
      "Returns:\n",
      "  A list containing:\n",
      "  - pattern_realizations_list: The list of generated movement patterns.\n",
      "  - observations_multiple_days: The simulated observations over multiple days.\n",
      "  - seq_of_extreme: The sequence of extreme values (min and max coordinates).\n\n",
      "Examples:\n",
      "  obs_info = data_generation(7, 'even_space', 479, 0.1, c(0, 1), 20250224)\n",
      "  patterns = obs_info[[1]]  # Movement patterns\n",
      "  observations = obs_info[[2]]  # Observed data\n",
      "  extremes = obs_info[[3]]  # Extreme coordinates\n\n",
      "To view function details, run:\n",
      "  data_generation_help()\n",
      sep = "")
}

# Helper function to display function documentation manually
kde_gps_help <- function() {
  cat("Kernel Density Estimation (KDE) for GPS Data\n\n",
      "This function estimates spatial-temporal density distributions of observations \n",
      "using different kernel density estimation (KDE) methods.\n\n",
      "Usage:\n",
      "  kde_gps(obs_input, grid_center_need, method, t_range_need=NULL, \n",
      "          time_interval=c(0, 0.99999), hs_const=0.8, ht_const=0.3)\n\n",
      "Arguments:\n",
      "  obs_input (data.frame) - The observed data containing timestamps and coordinates.\n",
      "  grid_center_need (matrix) - The grid centers where KDE is estimated.\n",
      "  method (string) - The KDE method to use ('naive', 'marginal', 'integral_conditional', 'naive_naive_bandwidth').\n",
      "  t_range_need (vector, optional) - Time range for integral conditional KDE.\n",
      "  time_interval (vector) - Time range for KDE estimation.\n",
      "  hs_const (numeric) - Smoothing parameter for spatial bandwidth.\n",
      "  ht_const (numeric) - Smoothing parameter for temporal bandwidth.\n\n",
      "Returns:\n",
      "  A density estimate for the specified method and grid centers.\n\n",
      "Examples:\n",
      "  # Compute KDE for all observations\n",
      "  marginal_density = kde_gps(observations_multiple_days, grid_center_need, 'marginal')\n",
      "  integral_density = kde_gps(observations_multiple_days, grid_center_need, \n",
      "                            'integral_conditional', t_range_need=t_range_need)\n\n",
      "  # Compute KDE for weekdays only\n",
      "  marginal_density_weekdays = kde_gps(observations_multiple_days_weekdays, grid_center_need, 'marginal')\n",
      "  integral_density_weekdays = kde_gps(observations_multiple_days_weekdays, grid_center_need, \n",
      "                                     'integral_conditional', t_range_need=t_range_need)\n\n",
      "To view function details, run:\n",
      "  kde_gps_help()\n",
      sep = "")
}

# Helper function to display function documentation manually
anchors_loading_help <- function() {
  cat("Loading Anchor Points Data\n\n",
      "This script loads anchor points from a CSV file and converts them into a matrix format.\n\n",
      "Usage:\n",
      "  anchors_df_path <- paste0(getwd(), '/data_to_read/anchors.csv')\n",
      "  anchors_df = read.csv(anchors_df_path)\n",
      "  anchors_mat = as.matrix(anchors_df[, c('x', 'y')])\n\n",
      "Arguments:\n",
      "  The script assumes that the CSV file contains at least two columns named 'x' and 'y'.\n",
      "  The function reads the data, extracts these columns, and converts them into a matrix.\n\n",
      "Returns:\n",
      "  A matrix containing the anchor points.\n\n",
      "Examples:\n",
      "  # Load anchor points\n",
      "  anchors_df_path <- paste0(getwd(), '/data_to_read/anchors.csv')\n",
      "  anchors_df = read.csv(anchors_df_path)\n",
      "  anchors_mat = as.matrix(anchors_df[, c('x', 'y')])\n",
      "  print(anchors_mat)\n\n",
      "To view function details, run:\n",
      "  anchors_loading_help()\n",
      sep = "")
}

find_local_maxima_discrete_help <- function() {
  cat("Find Local Maxima in a 2D Grid-Based Density Estimate\n\n",
      "This function identifies discrete local maxima in a 2D grid-based density estimate.\n",
      "A local maximum is a point whose density value is greater than or equal to all\n",
      "its 8 neighboring points.\n\n",
      "Usage:\n",
      "  find_local_maxima_discrete(grid_center_need, density_values)\n\n",
      "Arguments:\n",
      "  grid_center_need (matrix) - The coordinates of grid centers.\n",
      "  density_values (vector) - The estimated density values at each grid center.\n\n",
      "Returns:\n",
      "  A data frame with the indices, coordinates, and density values of local maxima.\n\n",
      "Examples:\n",
      "  discrete_peaks = find_local_maxima_discrete(grid_center_need, inte_conditional_esti_density)\n",
      "  activity_space_indices = as.numeric(discrete_peaks$ind[which(discrete_peaks$f_value > 0.025)])\n\n",
      "  # Weekday-specific estimation\n",
      "  discrete_peaks_weekdays = find_local_maxima_discrete(grid_center_need, inte_conditional_esti_density_weekdays)\n",
      "  activity_space_indices_weekdays = as.numeric(discrete_peaks_weekdays$ind[which(discrete_peaks_weekdays$f_value > 0.025)])\n\n",
      "To view function details, run:\n",
      "  find_local_maxima_discrete_help()\n",
      sep = "")
}

# Helper function to display function documentation manually
anchor_point_detect_plot_help <- function() {
  cat("Anchor Point Detection and Visualization\n\n",
      "This function plots detected anchor points against actual anchor points,\n",
      "allowing for comparison and evaluation of the detection algorithm.\n\n",
      "Usage:\n",
      "  anchor_point_detect_plot(activity_space_indices, anchors_mat, grid_center_need, \n",
      "                           title, seq_of_extreme, save_path_name='No')\n\n",
      "Arguments:\n",
      "  activity_space_indices (vector) - Indices of detected anchor points.\n",
      "  anchors_mat (matrix) - The actual anchor point coordinates.\n",
      "  grid_center_need (matrix) - Grid center coordinates.\n",
      "  title (string) - The plot title.\n",
      "  seq_of_extreme (vector) - The extreme values of the grid for plotting.\n",
      "  save_path_name (string) - The file path to save the plot (default: 'No' to disable saving).\n\n",
      "Returns:\n",
      "  A visualization comparing detected and actual anchor points.\n\n",
      "Examples:\n",
      "  anchor_point_detect_plot(activity_space_indices, anchors_mat, grid_center_need, \n",
      "                           'Actual v.s. Detected Anchor Points (overall)', \n",
      "                           seq_of_extreme, \n",
      "                           save_path_name='pic/more_simulations/anchor_points/anchor_points_overall.pdf')\n\n",
      "  anchor_point_detect_plot(activity_space_indices_weekdays, anchors_mat[c(1,2,3),], grid_center_need, \n",
      "                           'Actual v.s. Detected Anchor Points (weekdays)', \n",
      "                           seq_of_extreme, \n",
      "                           save_path_name='pic/more_simulations/anchor_points/anchor_points_weekdays.pdf')\n\n",
      "To view function details, run:\n",
      "  anchor_point_detect_plot_help()\n",
      sep = "")
}

activity_space_plot_help <- function() {
  cat("Activity Space Visualization\n\n",
      "This function visualizes activity spaces using level set methods based on KDE estimates.\n\n",
      "Usage:\n",
      "  activity_space_plot(dat2, idx_select, title_need, goal_interval, \n",
      "                      time_text='whole day', method='integral_conditional', \n",
      "                      save_path_name='No')\n\n",
      "Arguments:\n",
      "  dat2 (data.frame) - The dataset containing observed points.\n",
      "  idx_select (vector) - Indices of selected observations.\n",
      "  title_need (string) - Title for the plot.\n",
      "  goal_interval (vector) - Time interval for KDE estimation.\n",
      "  time_text (string, optional) - Label for the time period (default: 'whole day').\n",
      "  method (string) - KDE method to use ('integral_conditional' or other).\n",
      "  save_path_name (string) - File path to save the plot (default: 'No' to disable saving).\n\n",
      "Returns:\n",
      "  A visualization of activity space contours.\n\n",
      "Examples:\n",
      "  activity_space_plot(observations_multiple_days, c(1:nrow(observations_multiple_days)), \n",
      "                      'overall', goal_interval, method='integral_conditional', \n",
      "                      save_path_name='pic/more_simulations/activity_space/activity_space_alldays.pdf')\n\n",
      "  activity_space_plot(observations_multiple_days_weekdays, c(1:nrow(observations_multiple_days_weekdays)), \n",
      "                      'weekdays', goal_interval, method='integral_conditional', \n",
      "                      save_path_name='pic/more_simulations/activity_space/activity_space_weekdays.pdf')\n\n",
      "  activity_space_plot(observations_multiple_days_weekends, c(1:nrow(observations_multiple_days_weekends)), \n",
      "                      'weekends', goal_interval, method='integral_conditional', \n",
      "                      save_path_name='pic/more_simulations/activity_space/activity_space_weekends.pdf')\n\n",
      "To view function details, run:\n",
      "  activity_space_plot_help()\n",
      sep = "")
}


# Helper function to display function documentation manually
single_day_densities_help <- function() {
  cat("Kernel Density Estimation for Each Individual Day\n\n",
      "This function computes kernel density estimates (KDE) for each day separately,\n",
      "providing detailed insights into day-to-day density variations.\n\n",
      "Usage:\n",
      "  single_day_densities(observations_multiple_days, grid_center_need, \n",
      "                       goal_interval, method='marginal', t_range_need=NULL)\n\n",
      "Arguments:\n",
      "  observations_multiple_days (data.frame) - The dataset containing observed points across multiple days.\n",
      "  grid_center_need (matrix) - The coordinates of grid centers for KDE estimation.\n",
      "  goal_interval (vector) - The time interval for KDE estimation.\n",
      "  method (string, optional) - KDE method to use ('marginal', 'integral_conditional', etc.), default is 'marginal'.\n",
      "  t_range_need (vector, optional) - Sequence of time points for density estimation.\n\n",
      "Returns:\n",
      "  A list where each element contains the KDE result for a specific day.\n\n",
      "Examples:\n",
      "  # Compute KDE for each day in the dataset\n",
      "  t_range_need = seq(goal_interval[1], goal_interval[2], length.out = 99)\n",
      "  all_res_single_day_all = single_day_densities(observations_multiple_days, grid_center_need, \n",
      "                                                goal_interval, method='integral_conditional', \n",
      "                                                t_range_need=t_range_need)\n\n",
      "To view function details, run:\n",
      "  single_day_densities_help()\n",
      sep = "")
}

# Helper function to display function documentation manually
cluster_pattern_help <- function() {
  cat("Spectral Clustering for Daily Movement Patterns\n\n",
      "This function clusters daily movement patterns based on KDE estimates using spectral clustering.\n",
      "It computes a similarity graph (Laplacian matrix) and applies the spectral clustering algorithm.\n\n",
      "Usage:\n",
      "  cluster_pattern(all_res_single_day_all, pattern_realizations_list, pattern_chosen)\n\n",
      "Arguments:\n",
      "  all_res_single_day_all (list) - A list of daily KDE estimates.\n",
      "  pattern_realizations_list (list) - A list containing the real movement patterns.\n",
      "  pattern_chosen (vector) - A vector specifying which days should be clustered.\n\n",
      "Returns:\n",
      "  A list containing:\n",
      "  - cluster_result: The assigned clusters for each selected day.\n",
      "  - Lap_graph: The Laplacian graph matrix.\n",
      "  - real_group: The actual movement patterns.\n",
      "  - day_indices: Indices of selected days.\n\n",
      "Examples:\n",
      "  # Cluster movement patterns for weekends (days 3, 4, 5)\n",
      "  clusters_weekends_res = cluster_pattern(all_res_single_day_all, pattern_realizations_list, c(3,4,5))\n\n",
      "  # Cluster movement patterns for weekdays (days 1, 2)\n",
      "  clusters_weekdays_res = cluster_pattern(all_res_single_day_all, pattern_realizations_list, c(1,2))\n\n",
      "To view function details, run:\n",
      "  cluster_pattern_help()\n",
      sep = "")
}

# Helper function to display function documentation manually
plot_heatmap_help <- function() {
  cat("Plot Heatmap of Spectral Clustering Results\n\n",
      "This function visualizes the affinity matrix ordered by spectral clustering\n",
      "for a given set of movement patterns.\n\n",
      "Usage:\n",
      "  plot_heatmap(clusters_res, title, save_path_name='No')\n\n",
      "Arguments:\n",
      "  clusters_res (list) - The result of the clustering process.\n",
      "  title (string) - Title of the plot.\n",
      "  save_path_name (string) - File path to save the plot (default: 'No' to disable saving).\n\n",
      "Returns:\n",
      "  A heatmap of the affinity matrix sorted by spectral clustering.\n\n",
      "Examples:\n",
      "  # Plot affinity matrix for weekdays\n",
      "  plot_heatmap(clusters_weekdays_res, \n",
      "               'Affinity Matrix Ordered by Spectral Clustering (Weekdays)', \n",
      "               save_path_name='pic/more_simulations/clustering/affinity_matrix_weekdays.pdf')\n\n",
      "  # Plot affinity matrix for weekends\n",
      "  plot_heatmap(clusters_weekends_res, \n",
      "               'Affinity Matrix Ordered by Spectral Clustering (Weekends)', \n",
      "               save_path_name='pic/more_simulations/clustering/affinity_matrix_weekends.pdf')\n\n",
      "To view function details, run:\n",
      "  plot_heatmap_help()\n",
      sep = "")
}

# Helper function to display function documentation manually
cluster_plot_help <- function() {
  cat("Hierarchical Clustering Dendrogram for Movement Patterns\n\n",
      "This function visualizes hierarchical clustering results (single linkage method)\n",
      "for different movement patterns based on KDE estimates.\n\n",
      "Usage:\n",
      "  cluster_plot(clusters_res, abline_h, loc, pattern_chosen, title, save_path_name='No')\n\n",
      "Arguments:\n",
      "  clusters_res (list) - The result of the clustering process.\n",
      "  abline_h (numeric) - The height at which to draw a horizontal line in the dendrogram.\n",
      "  loc (vector) - A vector specifying cluster label positions.\n",
      "  pattern_chosen (vector) - The pattern labels assigned to each cluster.\n",
      "  title (string) - Title of the plot.\n",
      "  save_path_name (string) - File path to save the plot (default: 'No' to disable saving).\n\n",
      "Returns:\n",
      "  A hierarchical clustering dendrogram based on spectral clustering results.\n\n",
      "Examples:\n",
      "  # Generate dendrogram for weekdays\n",
      "  cluster_plot(clusters_weekdays_res, abline_h = 65, loc = c(22,55), \n",
      "               pattern_chosen = c(1,2), title = 'Dendrogram (single linkage), weekdays', \n",
      "               save_path_name='pic/more_simulations/clustering/dendrogram_weekdays.pdf')\n\n",
      "  # Generate dendrogram for weekends\n",
      "  cluster_plot(clusters_weekends_res, abline_h = 200, loc = c(18,2,8), \n",
      "               pattern_chosen = c(3,4,5), title = 'Dendrogram (single linkage), weekends', \n",
      "               save_path_name='pic/more_simulations/clustering/dendrogram_weekends.pdf')\n\n",
      "To view function details, run:\n",
      "  cluster_plot_help()\n",
      sep = "")
}


# Helper function to display function documentation manually
cluster_densities_help <- function() {
  cat("Kernel Density Estimation for Movement Clusters\n\n",
      "This function computes KDE for different movement pattern clusters at specified time points.\n",
      "Each cluster is analyzed separately, and KDE estimates are stored in a nested list.\n\n",
      "Usage:\n",
      "  cluster_densities(observations_multiple_days, pattern_realizations_list, grid_center_need, \n",
      "                    pattern_vec=c(1:5), t_range_need_condi, method='integral_conditional')\n\n",
      "Arguments:\n",
      "  observations_multiple_days (data.frame) - The dataset containing observed points.\n",
      "  pattern_realizations_list (list) - A list containing the real movement patterns.\n",
      "  grid_center_need (matrix) - The coordinates of grid centers for KDE estimation.\n",
      "  pattern_vec (vector, optional) - The clusters for which densities should be computed (default: 1:5).\n",
      "  t_range_need_condi (vector, optional) - Time points for KDE estimation.\n",
      "  method (string, optional) - KDE method to use (default: 'integral_conditional').\n\n",
      "Returns:\n",
      "  A nested list where:\n",
      "  - Each element corresponds to a movement pattern cluster.\n",
      "  - Each sublist contains KDE estimates at different time points.\n\n",
      "Examples:\n",
      "  # Define time points for KDE estimation\n",
      "  t_range_need_condi = c(6/24, 9/24, 12/24, 15/24, 18/24, 21/24)\n\n",
      "  # Compute KDE for different movement pattern clusters\n",
      "  all_res_single_cluster_all_f = cluster_densities(observations_multiple_days, \n",
      "                                                   pattern_realizations_list, grid_center_need, \n",
      "                                                   pattern_vec = c(1:5), t_range_need_condi = t_range_need_condi, \n",
      "                                                   method='integral_conditional')\n\n",
      "To view function details, run:\n",
      "  cluster_densities_help()\n",
      sep = "")
}

conditional_density_plot_help <- function() {
  cat("Conditional Density Plot for Movement Clusters\n\n",
      "This function visualizes the log-density of spatial distributions for a given cluster\n",
      "at a specific time. It generates contour plots and saves them if a path is provided.\n\n",
      "Usage:\n",
      "  conditional_density_plot(all_res_single_cluster_all_f, cluster_id, grid_center_need, \n",
      "                           time_id, t_range_text, min_max_range, eps=0.0001, \n",
      "                           save_path_name='No')\n\n",
      "Arguments:\n",
      "  all_res_single_cluster_all_f (list) - List of density estimates for different clusters and times.\n",
      "  cluster_id (integer) - The cluster ID for which the plot is generated.\n",
      "  grid_center_need (matrix) - Coordinates of grid centers for contour plotting.\n",
      "  time_id (integer) - The index of the time point in the t_range_text vector.\n",
      "  t_range_text (vector) - The human-readable labels for each time point.\n",
      "  min_max_range (numeric vector) - The range for color scaling.\n",
      "  eps (numeric, optional) - A small constant added to avoid log(0) issues (default: 0.0001).\n",
      "  save_path_name (string, optional) - The file path to save the plot (default: 'No' to disable saving).\n\n",
      "Returns:\n",
      "  A contour plot of the log-density estimate for the given cluster at the specified time.\n\n",
      "Examples:\n",
      "  # Generate a log-density plot for Cluster 1 at 6:00 AM\n",
      "  conditional_density_plot(all_res_single_cluster_all_f, 1, grid_center_need, \n",
      "                           1, t_range_text, min_max_range, \n",
      "                           save_path_name='pic/more_simulations/conditional_density/cluster_1_6AM.pdf')\n\n",
      "To view function details, run:\n",
      "  conditional_density_plot_help()\n",
      sep = "")
}

cluster_centers_help <- function() {
  cat("Compute Estimated Centers of Movement for Clusters\n\n",
      "This function estimates the center of movement for different clusters at specified time points.\n",
      "It uses a kernel-weighted mean based on observed data timestamps.\n\n",
      "Usage:\n",
      "  cluster_centers(observations_multiple_days, pattern_realizations_list, grid_center_need, \n",
      "                 pattern_vec = c(1:5), t_range_need_condi)\n\n",
      "Arguments:\n",
      "  observations_multiple_days (data.frame) - The dataset containing observed points.\n",
      "  pattern_realizations_list (list) - A list containing the real movement patterns.\n",
      "  grid_center_need (matrix) - The coordinates of grid centers for KDE estimation.\n",
      "  pattern_vec (vector, optional) - The clusters for which centers should be computed (default: 1:5).\n",
      "  t_range_need_condi (vector, optional) - Time points for center estimation.\n\n",
      "Returns:\n",
      "  A list containing:\n",
      "  - center_x_list: List of x-coordinates for cluster centers at different time points.\n",
      "  - center_y_list: List of y-coordinates for cluster centers at different time points.\n\n",
      "Examples:\n",
      "  # Define time points for center estimation\n",
      "  t_range_need_condi = c(6/24, 9/24, 12/24, 15/24, 18/24, 21/24)\n\n",
      "  # Compute cluster centers\n",
      "  cluster_center_list = cluster_centers(observations_multiple_days, pattern_realizations_list, \n",
      "                                       grid_center_need, pattern_vec = c(1:5), \n",
      "                                       t_range_need_condi = t_range_need_condi)\n\n",
      "  # Extract x and y coordinates of cluster centers\n",
      "  all_res_single_cluster_all_x = cluster_center_list$center_x_list\n",
      "  all_res_single_cluster_all_y = cluster_center_list$center_y_list\n\n",
      "To view function details, run:\n",
      "  cluster_centers_help()\n",
      sep = "")
}


dense_centroid_plot_help <- function() {
  cat("Plot Estimated Centroids of Movement Clusters\n\n",
      "This function visualizes the estimated centroids of movement clusters at different times.\n",
      "It uses kernel-weighted averaging to compute the centroid for each cluster.\n\n",
      "Usage:\n",
      "  dense_centroid_plot(all_res_single_cluster_all_x, all_res_single_cluster_all_y, \n",
      "                      cluster_no, t_range_text, observations_multiple_days, \n",
      "                      t_range_need_condi, save_path_name='No')\n\n",
      "Arguments:\n",
      "  all_res_single_cluster_all_x (list) - List of x-coordinates for cluster centers.\n",
      "  all_res_single_cluster_all_y (list) - List of y-coordinates for cluster centers.\n",
      "  cluster_no (integer) - The cluster ID to plot. Use 0 for all observations.\n",
      "  t_range_text (vector) - Human-readable time labels for each centroid.\n",
      "  observations_multiple_days (data.frame) - The dataset containing observed points.\n",
      "  t_range_need_condi (vector) - Time points for centroid estimation.\n",
      "  save_path_name (string, optional) - File path to save the plot (default: 'No' to disable saving).\n\n",
      "Returns:\n",
      "  A ggplot visualization of estimated cluster centroids.\n\n",
      "Examples:\n",
      "  # Generate centroid plots for all clusters\n",
      "  for (cluster_no in c(0:5)) {\n",
      "    dense_centroid_plot(all_res_single_cluster_all_x, all_res_single_cluster_all_y, \n",
      "                        cluster_no, t_range_text, observations_multiple_days, \n",
      "                        t_range_need_condi, \n",
      "                        save_path_name=paste0('pic/more_simulations/centers/cluster_', cluster_no, '.pdf'))\n",
      "  }\n\n",
      "To view function details, run:\n",
      "  dense_centroid_plot_help()\n",
      sep = "")
}

velocity_estimate_help <- function() {
  cat("Estimate Movement Velocity Based on Loess Smoothing\n\n",
      "This function estimates movement velocity by fitting loess models\n",
      "to x and y coordinates separately and computing numerical derivatives.\n\n",
      "Usage:\n",
      "  velocity_estimate(trial, pattern_realizations_list, observations_multiple_days)\n\n",
      "Arguments:\n",
      "  trial (integer) - The cluster ID. Use 0 for all observations.\n",
      "  pattern_realizations_list (list) - List containing real movement patterns.\n",
      "  observations_multiple_days (data.frame) - Dataset with observed points.\n\n",
      "Returns:\n",
      "  A list containing:\n",
      "  - t_grid: The time grid for velocity estimation.\n",
      "  - velocity: Estimated velocity values.\n\n",
      "Examples:\n",
      "  # Estimate velocity for all movement patterns (overall)\n",
      "  velocity_estimation = velocity_estimate(0, pattern_realizations_list, observations_multiple_days)\n\n",
      "  # Estimate velocity for a specific movement pattern (e.g., Cluster 1)\n",
      "  velocity_estimation_cluster1 = velocity_estimate(1, pattern_realizations_list, observations_multiple_days)\n\n",
      "To view function details, run:\n",
      "  velocity_estimate_help()\n",
      sep = "")
}